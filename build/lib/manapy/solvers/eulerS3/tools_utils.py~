from numba import njit
import numpy as np
from scipy.optimize import newton
import meshio 
from scipy import optimize
from manapy.solution_refcsv.ref import interpo, initialize_multiple_interpolations

######################################exact_solution##############################"
@njit
def f(p:'float', alpha:'float', pl:'float', pr:'float', al:'float', ar:'float', rl:'float', rr:'float', gamma:'float'):
    if alpha == 1:
        p_alpha = pl
        a_alpha = al
        A_alpha = 2. / (rl * (gamma + 1.))
        B_alpha = (gamma - 1.) / (gamma + 1.) * pl
    elif alpha == 2:
        p_alpha = pr
        a_alpha = ar
        A_alpha = 2. / (rr * (gamma + 1.))
        B_alpha = (gamma - 1.) / (gamma + 1.) * pr
    else:
        raise ValueError("Invalid alpha value. Must be 'L' or 'R'")

    if p > p_alpha:
        return (p - p_alpha) * np.sqrt(A_alpha / (p + B_alpha))
    else:
        return 2. * a_alpha / (gamma - 1.) * ((p / p_alpha) ** ((gamma - 1.) / (2. * gamma)) - 1.)

@njit
def g(w:'float', ul:'float', ur:'float', pl:'float', pr:'float', al:'float', ar:'float', rl:'float', rr:'float', gamma:'float'):
    return f(w, 1, pl, pr, al, ar, rl, rr, gamma) + f(w, 2, pl, pr, al, ar, rl, rr, gamma) + ur - ul
@njit
def dichotomie(bas:'float', haut:'float', ul:'float', ur:'float', pl:'float', pr:'float', al:'float', ar:'float', rl:'float', rr:'float', gamma:'float'):
    lower, upper = bas, haut
    while g(lower, ul, ur, pl, pr, al, ar, rl, rr, gamma) * g(upper, ul, ur, pl, pr, al, ar, rl, rr, gamma) > 0:
        upper = 2.0 * upper

    while upper - lower > 1e-8:
        middle = 0.5 * (upper + lower)
        if g(middle, ul, ur, pl, pr, al, ar, rl, rr, gamma) > 0:
            lower, upper = lower, middle
        else:
            lower, upper = middle, upper

    return 0.5 * (upper + lower)
@njit
def Exact_E(N:'float', x:'float', t:'float', x_0:'float', xmax:'float', gamma:'float', rl:'float', rr:'float', ul:'float', ur:'float', pl:'float', pr:'float'):
    r = np.zeros(N)  
    p = np.zeros(N) 
    u = np.zeros(N)  

    al = np.sqrt(gamma * pl / rl)
    ar = np.sqrt(gamma * pr / rr)
    p_star = dichotomie(0.0, max(pl, pr), ul, ur, pl, pr, al, ar, rl, rr, gamma)
    u_star = (ul + ur + f(p_star, 2, pl, pr, al, ar, rl, rr, gamma) - f(p_star, 1, pl, pr, al, ar, rl, rr, gamma)) * 0.5

    if p_star > pl:
        r_star_l = rl * (p_star / pl + (gamma - 1.) / (gamma + 1.)) / ((gamma - 1.) / (gamma + 1.) * p_star / pl + 1.)
    else:
        r_star_l = rl * (p_star / pl) ** (1. / gamma)

    a_star_l = al * (p_star / pl) ** ((gamma - 1.) / (2. * gamma))
    sigma_l = ul - al * np.sqrt((gamma + 1.) / (2. * gamma) * (p_star / pl) + (gamma - 1.) / (2. * gamma))
    sigma_H_l = ul - al
    sigma_T_l = u_star - a_star_l

    if p_star > pr:
        r_star_r = rr * (p_star / pr + (gamma - 1.) / (gamma + 1.)) / ((gamma - 1.) / (gamma + 1.) * (p_star / pr) + 1.)
    else:
        r_star_r = rr * (p_star / pr) ** (1. / gamma)

    a_star_r = ar * (p_star / pr) ** ((gamma - 1.) / (2. * gamma))
    sigma_r = ur + ar * np.sqrt((gamma + 1.) / (2. * gamma) * (p_star / pr) + (gamma - 1.) / (2. * gamma))
    sigma_H_r = ur + ar
    sigma_T_r = u_star + a_star_r

    for i in range(N):
        if p_star > pl:  # Gauche = choc
            if x[i] - xmax * x_0 < sigma_l * t:
                r[i], p[i], u[i] = rl, pl, ul
            elif sigma_l * t <= x[i] - xmax * x_0 <= u_star * t:
                r[i], p[i], u[i] = r_star_l, p_star, u_star
        else:  # Gauche = detente
            if x[i] - xmax * x_0 < sigma_H_l * t:
                r[i], p[i], u[i] = rl, pl, ul
            elif sigma_H_l * t <= x[i] - xmax * x_0 < sigma_T_l * t:
                r[i] = rl * (2. / (gamma + 1.) + (gamma - 1.) / ((gamma + 1.) * al) * (ul - (x[i] - x_0) / t)) ** (2. / (gamma - 1.))
                p[i] = pl * (2. / (gamma + 1.) + (gamma - 1.) / ((gamma + 1.) * al) * (ul - (x[i] - x_0) / t)) ** (2. * gamma / (gamma - 1.))
                u[i] = 2. / (gamma + 1.) * (al + (gamma - 1.) * 0.5 * ul + (x[i] - x_0) / t)
            elif sigma_T_l * t <= x[i] - xmax * x_0 <= u_star * t:
                r[i], p[i], u[i] = r_star_l, p_star, u_star

        if p_star > pr:  # Droite = choc
            if x[i] - xmax * x_0 > sigma_r * t:
                r[i], p[i], u[i] = rr, pr, ur
            elif u_star * t <= x[i] - xmax * x_0 <= sigma_r * t:
                r[i], p[i], u[i] = r_star_r, p_star, u_star
        else:  # Droite = detente
            if x[i] - xmax * x_0 > sigma_H_r * t:
                r[i], p[i], u[i] = rr, pr, ur
            elif sigma_T_r * t < x[i] - xmax * x_0 <= sigma_H_r * t:
                r[i] = rr * (2. / (gamma + 1.) - (gamma - 1.) / ((gamma + 1.) * ar) * (ur - (x[i] - x_0) / t)) ** (2. / (gamma - 1.))
                p[i] = pr * (2. / (gamma + 1.) - (gamma - 1.) / ((gamma + 1.) * ar) * (ur - (x[i] - x_0) / t)) ** (2. * gamma / (gamma - 1.))
                u[i] = 2. / (gamma + 1.) * (-ar + (gamma - 1.) * 0.5 * ur + (x[i] - x_0) / t)
            elif u_star * t <= x[i] - xmax * x_0 <= sigma_T_r * t:
                r[i], p[i], u[i] = r_star_r, p_star, u_star

    return r, u, p



@njit
def Exact_Euler(rho_exact:'float[:]', u_exact:'float[:]', E_exact:'float[:]',e_internal_exact:'float[:]', P_exact:'float[:]', center:'float[:,:]',rl:'float',
                pl:'float', ul:'float',rr:'float', pr:'float',ur:'float',x_0:'flaot',xmin:'float', xmax:'float',time:'float', gamma='float'):

    nbelement=len(center)
    #x=np.linspace(xmin,xmax,N)
    x=[center[i][0]for i in range(nbelement)]
    r, u, p = Exact_E(nbelement, x, time, x_0, xmax, gamma, rl, rr, ul, ur, pl, pr)
    for i in range(nbelement):
        rho_exact[i] = r[i]
        u_exact[i]=  u[i] 
        e_internal_exact[i] = p[i] / (r[i] * (gamma - 1.))
        E_exact[i]=  (0.5 * u[i]**2)/r[i] + p[i] / (r[i] * (gamma - 1.))
        P_exact[i]=p[i]


################################### norms to compute error #######################""

@njit
def norm_L1(rho_exact:'float[:]', u_exact:'float[:]', E_exact:'float[:]', 
            rho:'float[:]', rhou:'float[:]', rhoE:'float[:]', 
            center:'float[:,:]', vol:'float[:]'):
    Err_rho = 0.0  
    Err_rhou = 0.0  
    Err_rhoE = 0.0  
    relative_rho=0.0
    relative_rhou=0.0
    relative_rhoE=0.0

    nbelement = len(center)

    for i in range(nbelement):
        Err_rho += vol[i] * np.abs(rho_exact[i] - rho[i])
        Err_rhou += vol[i] * np.abs(rho_exact[i] * u_exact[i] - rhou[i]) 
        Err_rhoE += vol[i] *   np.abs(rho_exact[i] * E_exact[i] - rhoE[i])

        relative_rho+=vol[i]*np.abs(rho_exact[i])
        relative_rhou+=vol[i]*np.abs(rho_exact[i]*u_exact[i])
        relative_rhoE+=vol[i]*np.abs(rho_exact[i]*E_exact[i])
    

    Err_rho=Err_rho/  relative_rho
    Err_rhou=Err_rhou/  relative_rhou
    Err_rhoE=Err_rhoE/  relative_rhoE

    print(" relative L1 error in rho is:", Err_rho)
    print("relative  L1 error in rhou is:", Err_rhou)
    print(" relative L1 error in rhoE is:", Err_rhoE)
   

@njit
def norm_Linf(rho_exact:'float[:]', u_exact:'float[:]', E_exact:'float[:]', 
              rho:'float[:]', rhou:'float[:]', rhoE:'float[:]', 
              center:'float[:,:]', vol:'float[:]'):
    nbelement = len(center)
    Err_rho  = 0.0  
    Err_rhou=0.0
    Err_rhoE=0.0
   

    for i in range(nbelement):
        
        Err_rho = max(np.abs(rho_exact[i] - rho[i]),Err_rho) 
        Err_rhou = max(np.abs(rho_exact[i]*u_exact[i] - rhou[i]),Err_rhou) 
        Err_rhoE = max(np.abs(rho_exact[i]*E_exact[i] - rhoE[i]),Err_rhoE) 
        

      
    print("The L_infinity error in rho is", Err_rho)
    print("The L_infinity error in rhou is", Err_rhou)
    print("The L_infinity error in rhoE is", Err_rhoE)

'''
# Charger le fichier et initialiser les interpolations
csv_file ="/home/asus/manapy/manapy/solution_refcsv/ref_allvar.csv"
initialize_multiple_interpolations(csv_file, variables=["rho", "u", "E", "e_internal", "p"])



def Exact(rho_exact:'float[:]', u_exact:'float[:]', E_exact:'float[:]',e_internal_exact:'float[:]', P_exact:'float[:]', center:'float[:,:]'):

    nbelement=len(center)
    for i in range (nbelement):

        rho_exact[i]=interpo("rho",center[i][0],center[i][1])
        u_exact[i]=interpo("u",center[i][0],center[i][1])
        E_exact[i]=interpo("E",center[i][0],center[i][1])
        e_internal_exact[i]=interpo("e_internal",center[i][0],center[i][1])
        P_exact[i]=interpo("p",center[i][0],center[i][1])


'''


################################test11#####################################



@njit
def initialisation_tubeChok11exac(rho_exact:'float[:]', u_exact:'float[:]', E_exact:'float[:]', e_internal_exact:'float[:]', P_exact:'float[:]', center:'float[:,:]', gamma:'float'):

    nbelements = len(center)
    
    for i in range(nbelements):
        xcent = center[i][0]
        #print(xcent)
        if xcent< 0.5:
            rho_exact[i]=6
            u_exact[i]=19.6
            P_exact[i]=460
            E_exact[i]=(P_exact[i]/(gamma-1) +0.5*(u_exact[i]**2))/rho_exact[i]
            e_internal_exact[i]=P_exact[i]/((gamma-1)*rho_exact[i] )
        else:
            rho_exact[i]=6
            u_exact[i]=-6.2
            P_exact[i]=46
            E_exact[i]=(P_exact[i]/(gamma-1) +0.5*(u_exact[i]**2))/rho_exact[i]
            e_internal_exact[i]=P_exact[i]/((gamma-1)*rho_exact[i] )



@njit
def initialisation_tubeChok11(rho:'float[:]', rhou:'float[:]', rhov:'float[:]', rhoE:'float[:]',e_internal:'float[:]', P:'float[:]', center:'float[:,:]', gamma='float'):
   
    nbelements = len(center)
    
    for i in range(nbelements):
        xcent = center[i][0]
        #print(xcent)
        if xcent< 0.5:
            rho[i]=6
            rhou[i]=19.6
            rhov[i]=0
            P[i]=460
            rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
            e_internal[i]=P[i]/((gamma-1)*rho[i] )
        else:
            rho[i]=6
            rhou[i]=-6.2
            rhov[i]=0
            P[i]=46
            rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
            e_internal[i]=P[i]/((gamma-1)*rho[i] )



############################################################test22##############################################################
@njit
def initialisation_tubeChok22(rho:'float[:]', rhou:'float[:]', rhov:'float[:]', rhoE:'float[:]',e_internal:'float[:]', P:'float[:]', center:'float[:,:]', gamma='float'):
   
    nbelements = len(center)
    
    for i in range(nbelements):
        xcent = center[i][0]
        #print(xcent)
        if xcent< 0.5:
            rho[i]=1
            rhou[i]=0
            rhov[i]=0
            P[i]=1
            rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
            e_internal[i]=P[i]/((gamma-1)*rho[i] )
        else:
            rho[i]=0.125
            rhou[i]=0
            rhov[i]=0
            P[i]=0.1
            rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
            e_internal[i]=P[i]/((gamma-1)*rho[i] )


@njit
def initialisation_tubeChok22exac(rho_exact:'float[:]', u_exact:'float[:]', E_exact:'float[:]', e_internal_exact:'float[:]', P_exact:'float[:]', center:'float[:,:]', gamma:'float'):

    nbelements = len(center)
    
    for i in range(nbelements):
        xcent = center[i][0]
        #print(xcent)
        if xcent< 0.5:
            rho_exact[i]=1
            u_exact[i]=0
            P_exact[i]=1
            E_exact[i]=(P_exact[i]/(gamma-1) +0.5*(u_exact[i]**2))/rho_exact[i]
            e_internal_exact[i]=P_exact[i]/((gamma-1)*rho_exact[i] )
        else:
            rho_exact[i]=0.125
            u_exact[i]=0
            P_exact[i]=0.1
            E_exact[i]=(P_exact[i]/(gamma-1) +0.5*(u_exact[i]**2))/rho_exact[i]
            e_internal_exact[i]=P_exact[i]/((gamma-1)*rho_exact[i] )




######################################test1#######################################
@njit
def initialisation_tubeChok1(rho:'float[:]', rhou:'float[:]', rhov:'float[:]', rhoE:'float[:]',e_internal:'float[:]', P:'float[:]', center:'float[:,:]', gamma='float'):
   
    nbelements = len(center)
    
    for i in range(nbelements):
        xcent = center[i][0]
        #print(xcent)
        if xcent< 0.5:
            rho[i]=1
            rhou[i]=0.75
            rhov[i]=0
            P[i]=1
            rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
            e_internal[i]=P[i]/((gamma-1)*rho[i] )
        else:
            rho[i]=0.125
            rhou[i]=0
            rhov[i]=0
            P[i]=0.1
            rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
            e_internal[i]=P[i]/((gamma-1)*rho[i] )


@njit
def initialisation_tubeChok1exac(rho_exact:'float[:]', u_exact:'float[:]', E_exact:'float[:]', e_internal_exact:'float[:]', P_exact:'float[:]', center:'float[:,:]', gamma:'float'):

    nbelements = len(center)
    
    for i in range(nbelements):
        xcent = center[i][0]
        #print(xcent)
        if xcent< 0.5:
            rho_exact[i]=1
            u_exact[i]=0.75
            P_exact[i]=1
            E_exact[i]=(P_exact[i]/(gamma-1) +0.5*(u_exact[i]**2))/rho_exact[i]
            e_internal_exact[i]=P_exact[i]/((gamma-1)*rho_exact[i] )
        else:
            rho_exact[i]=0.125
            u_exact[i]=0
            P_exact[i]=0.1
            E_exact[i]=(P_exact[i]/(gamma-1) +0.5*(u_exact[i]**2))/rho_exact[i]
            e_internal_exact[i]=P_exact[i]/((gamma-1)*rho_exact[i] )

  


######################################test2#######################################

@njit
def initialisation_tubeChok2(rho:'float[:]', rhou:'float[:]', rhov:'float[:]', rhoE:'float[:]',e_internal:'float[:]', P:'float[:]', center:'float[:,:]', gamma='float'):
   
    nbelements = len(center)
    
    for i in range(nbelements):
        xcent = center[i][0]
        #print(xcent)
        if xcent< 0.5:
            rho[i]=1
            rhou[i]=0.0
            rhov[i]=0.0
            P[i]=10
            rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
            e_internal[i]=P[i]/((gamma-1)*rho[i] )
        else:
            rho[i]=0.125
            rhou[i]=0
            rhov[i]=0
            P[i]=1.0
            rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
            e_internal[i]=P[i]/((gamma-1)*rho[i] )


@njit
def initialisation_tubeChok2exac(rho_exact:'float[:]', u_exact:'float[:]', E_exact:'float[:]', e_internal_exact:'float[:]', P_exact:'float[:]', center:'float[:,:]', gamma:'float'):

    nbelements = len(center)
    
    for i in range(nbelements):
        xcent = center[i][0]
        #print(xcent)
        if xcent< 0.5:
            rho_exact[i]=1
            u_exact[i]=0.0
            P_exact[i]=10
            E_exact[i]=(P_exact[i]/(gamma-1) +0.5*(u_exact[i]**2))/rho_exact[i]
            e_internal_exact[i]=P_exact[i]/((gamma-1)*rho_exact[i] )
        else:
            rho_exact[i]=0.125
            u_exact[i]=0.0
            P_exact[i]=1.0
            E_exact[i]=(P_exact[i]/(gamma-1) +0.5*(u_exact[i]**2))/rho_exact[i]
            e_internal_exact[i]=P_exact[i]/((gamma-1)*rho_exact[i] )

  


########################################test3##########################################
@njit
def initialisation_tubeChok3(rho:'float[:]', rhou:'float[:]', rhov:'float[:]', rhoE:'float[:]',e_internal:'float[:]', P:'float[:]', center:'float[:,:]', gamma='float'):
   
    nbelements = len(center)
    
    for i in range(nbelements):
        xcent = center[i][0]
        #print(xcent)
        if xcent< 0.5:
            rho[i]=0.445
            rhou[i]=0.31061  #u=0.698
            rhov[i]=0
            P[i]=3.258
            rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
            e_internal[i]=P[i]/((gamma-1)*rho[i] )
        else:
            rho[i]=0.5
            rhou[i]=0
            rhov[i]=0
            P[i]=0.571
            rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
            e_internal[i]=P[i]/((gamma-1)*rho[i] )


@njit
def initialisation_tubeChok3exac(rho_exact:'float[:]', u_exact:'float[:]', E_exact:'float[:]', e_internal_exact:'float[:]', P_exact:'float[:]', center:'float[:,:]', gamma:'float'):

    nbelements = len(center)
    
    for i in range(nbelements):
        xcent = center[i][0]
        #print(xcent)
        if xcent< 0.5:
            rho_exact[i]=0.445
            u_exact[i]=0.31061
            P_exact[i]=3.258
            E_exact[i]=(P_exact[i]/(gamma-1) +0.5*(u_exact[i]**2))/rho_exact[i]
            e_internal_exact[i]=P_exact[i]/((gamma-1)*rho_exact[i] )
        else:
            rho_exact[i]=0.5
            u_exact[i]=0
            P_exact[i]=0.571
            E_exact[i]=(P_exact[i]/(gamma-1) +0.5*(u_exact[i]**2))/rho_exact[i]
            e_internal_exact[i]=P_exact[i]/((gamma-1)*rho_exact[i] )

  


    ########################################test4##########################################


@njit
def initialisation_tubeChok4(rho:'float[:]', rhou:'float[:]', rhov:'float[:]', rhoE:'float[:]',e_internal:'float[:]', P:'float[:]', center:'float[:,:]', gamma='float'):
   
    nbelements = len(center)
    
    for i in range(nbelements):
        xcent = center[i][0]
        #print(xcent)
        if xcent< 0.5:
            rho[i]=1
            rhou[i]=-2
            rhov[i]=0
            P[i]=0.4
            rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
            e_internal[i]=P[i]/((gamma-1)*rho[i] )
        else:
            rho[i]=1
            rhou[i]=2
            rhov[i]=0
            P[i]=0.4
            rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
            e_internal[i]=P[i]/((gamma-1)*rho[i] )

@njit
def initialisation_tubeChok4exac(rho_exact:'float[:]', u_exact:'float[:]', E_exact:'float[:]', e_internal_exact:'float[:]', P_exact:'float[:]', center:'float[:,:]', gamma:'float'):

    nbelements = len(center)
    
    for i in range(nbelements):
        xcent = center[i][0]
        #print(xcent)
        if xcent< 0.5:
            rho_exact[i]=1
            u_exact[i]=-2
            P_exact[i]=0.4
            E_exact[i]=(P_exact[i]/(gamma-1) +0.5*(u_exact[i]**2))/rho_exact[i]
            e_internal_exact[i]=P_exact[i]/((gamma-1)*rho_exact[i] )
        else:
            rho_exact[i]=1
            u_exact[i]=2
            P_exact[i]=0.4
            E_exact[i]=(P_exact[i]/(gamma-1) +0.5*(u_exact[i]**2))/rho_exact[i]
            e_internal_exact[i]=P_exact[i]/((gamma-1)*rho_exact[i] )



###########################################compute the h ##########################################
def step(vol:'float[:]', nbcells:'float64'):
    s=0
    N=int(nbcells)
  
    for i in range(N):
        s+=vol[i]
    h=np.sqrt(s/N)
    return h
    
def compute_p(h1:'float', h2:'float', error1:'float', error2:'float'):
        """Calcule l'ordre de convergence entre deux maillages."""
        return (np.log(error1) - np.log(error2)) / (np.log(h1) - np.log(h2))




##############################radially symmetric  Riemann problrm #####################################
@njit
def initialisation_RS(rho:'float[:]', rhou:'float[:]', rhov:'float[:]', rhoE:'float[:]',e_internal:'float[:]', P:'float[:]', center:'float[:,:]', gamma='float'):
   
    nbelements = len(center)
    for i in range(nbelements):
        xcent = center[i][0]
        ycent = center[i][1]
        #print(xcent)
        if np.sqrt(xcent**2+ycent**2)< 0.13:
            rho[i]=2.0
            rhou[i]=0
            rhov[i]=0
            P[i]=15.0
            rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
            e_internal[i]=P[i]/((gamma-1)*rho[i] )
        else:
            rho[i]=1.0
            rhou[i]=0
            rhov[i]=0
            P[i]=1.0
            rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
            e_internal[i]=P[i]/((gamma-1)*rho[i] )



##############################Double Mach reflection problem#####################################
@njit
def initialisation_DMR(rho:'float[:]', rhou:'float[:]', rhov:'float[:]', rhoE:'float[:]',e_internal:'float[:]', P:'float[:]', center:'float[:,:]', gamma='float'):
   
    nbelements = len(center)
    
    for i in range(nbelements):
        xcent = center[i][0]
        ycent = center[i][1]
        k= (1/6)+ ycent/(np.sqrt(3))
        #print(xcent)
        if xcent<k:
            rho[i]=8.0
            rhou[i]=8.0*8.25*(np.sqrt(3)/2)
            rhov[i]=-8.0*8.25*0.5
            P[i]=116.5
            rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
            e_internal[i]=P[i]/((gamma-1)*rho[i] )
        else:
            rho[i]=1.4
            rhou[i]=0.0
            rhov[i]=0.0
            P[i]=1.0
            rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
            e_internal[i]=P[i]/((gamma-1)*rho[i] )




#######################GAMM channel##################
@njit
def GAMM_channel(rho:'float[:]', rhou:'float[:]', rhov:'float[:]', rhoE:'float[:]',e_internal:'float[:]', P:'float[:]', center:'float[:,:]', gamma='float'):

    nbelements = len(rho)

    for i in range(nbelements):
        rho[i]   = 1.0948
        P[i]     = 90808.0041
        rhou[i]  = 0.
        rhov[i]  = 0.
        rhoE[i]=P[i]/(gamma-1) +0.5*(rhou[i]**2+rhov[i]**2)/(rho[i])
        e_internal[i]=P[i]/((gamma-1)*rho[i] )

    
#########################conditions au bord##############################
@njit
def ghost_value_slip(rhou_c:'float[:]', rhov_c:'float[:]',rho_c:'float[:]', w_ghost:'float[:]', 
                     cellid:'int32[:,:]', faces:'int32[:]', normal:'float[:,:]', mesure:'float[:]',choix:'int32'):

    s_n = np.zeros(3)
    for i in faces:
        u_i = rhou_c[cellid[i][0]]/rho_c[cellid[i][0]]
        v_i = rhov_c[cellid[i][0]]/rho_c[cellid[i][0]]
        
        s_n[:] = normal[i][:] / mesure[i]
        u_g = u_i*(s_n[1]*s_n[1] - s_n[0]*s_n[0]) - 2.0*v_i*s_n[0]*s_n[1]
        v_g = v_i*(s_n[0]*s_n[0] - s_n[1]*s_n[1]) - 2.0*u_i*s_n[0]*s_n[1]
        if choix==1:
            w_ghost[i] =rho_c[cellid[i][0]]* u_g
        else:
            w_ghost[i] =rho_c[cellid[i][0]]* v_g
            


        
        
@njit
def ghost_value_neumann(w_c:'float[:]', w_ghost:'float[:]', cellid:'int32[:,:]', faces:'uint32[:]'):
    
    for i in faces:
        w_ghost[i]  = w_c[cellid[i][0]]
        
@njit    
def ghost_value_neumannNH(w_c:'float[:]', w_ghost:'float[:]', cellid:'int32[:,:]', faces:'uint32[:]',
                          cst:'float[:]', dist:'float[:]'):
    for i in faces:
        w_ghost[i] = w_c[cellid[i][0]] + cst[i]*dist[i]

@njit
def ghost_value_dirichlet(value:'float', w_ghost:'float[:]', faces:'uint32[:]'):
    
    for i in faces:
        w_ghost[i]  = value
#################################halo value############################"
# 
################################### halo values#############################
def haloghost_value_neumann(w_halo:'float[:]', w_haloghost:'float[:]', haloghostcenter:'float[:,:,:]',
                            BCindex: 'int32', halonodes:'uint32[:]',  cst:'float[:]'):
    
    for i in halonodes:
        for j in range(len(haloghostcenter[i])):
            if haloghostcenter[i][j][-1] != -1:
                if haloghostcenter[i][j][-2] == BCindex:
                    cellhalo  = np.int32(haloghostcenter[i][j][-3])
                    cellghost = np.int32(haloghostcenter[i][j][-1])
    
                    w_haloghost[cellghost]   = w_halo[cellhalo]

def haloghost_value_neumannNH(w_halo:'float[:]', w_haloghost:'float[:]', haloghostcenter:'float[:,:,:]',
                            BCindex: 'int32', halonodes:'uint32[:]',  cst:'float[:]'):
    
    #TODO dist is not well computed (work only if NH is in the infaces)
    for i in halonodes:
        for j in range(len(haloghostcenter[i])):
            if haloghostcenter[i][j][-1] != -1:
                if haloghostcenter[i][j][-2] == BCindex:
                    cellhalo  = np.int32(haloghostcenter[i][j][-3])
                    cellghost = np.int32(haloghostcenter[i][j][-1])
                    dist = 2*distance(haloghostcenter[i][j][0:2], np.array([0., haloghostcenter[i][j][1]]))
    
                    w_haloghost[cellghost]   = w_halo[cellhalo] + cst[i]*dist

def haloghost_value_dirichlet(value:'float[:]', w_haloghost:'float[:]', haloghostcenter:'float[:,:,:]',
                              BCindex: 'int32', halonodes:'uint32[:]',  cst:'float[:]'):
    
    for i in halonodes:
        for j in range(len(haloghostcenter[i])):
            if haloghostcenter[i][j][-1] != -1:
                if haloghostcenter[i][j][-2] == BCindex:
                    cellghost = np.int32(haloghostcenter[i][j][-1])
                    w_haloghost[cellghost]   = value[cellghost]

def haloghost_value_nonslip(w_halo:'float[:]', w_haloghost:'float[:]', haloghostcenter:'float[:,:,:]',
                           BCindex: 'int32', halonodes:'uint32[:]',  cst:'float[:]'):
    
    for i in halonodes:
        for j in range(len(haloghostcenter[i])):
            if haloghostcenter[i][j][-1] != -1:
                if haloghostcenter[i][j][-2] == BCindex:
                    cellghost = np.int32(haloghostcenter[i][j][-1])
                    w_haloghost[cellghost]   = -1*w_halo[cellghost]


def haloghost_value_slip(u_halo:'float[:]', v_halo:'float[:]', w_haloghost:'float[:]', haloghostcenter:'float[:,:,:]',
                       BCindex: 'int32', halonodes:'int32[:]', haloghostfaceinfo:'float[:,:,:]'):
    
    s_n = np.zeros(2)
    for i in halonodes:
        for j in range(len(haloghostcenter[i])):
            if haloghostcenter[i][j][-1] != -1:
                if haloghostcenter[i][j][-2] == BCindex:
                    cellghost = int32(haloghostcenter[i][j][-1])

                    u_i = u_halo[cellghost]
                    v_i = v_halo[cellghost]
                    
                    mesure = np.sqrt(haloghostfaceinfo[i][j][2]**2 + haloghostfaceinfo[i][j][3]**2)# + haloghostfaceinfo[i][5]**2)
                    
                    s_n[0] = haloghostfaceinfo[i][j][2] / mesure
                    s_n[1] = haloghostfaceinfo[i][j][3] / mesure
                    
                    u_g = u_i*(s_n[1]*s_n[1] - s_n[0]*s_n[0]) - 2.0*v_i*s_n[0]*s_n[1]
                        
                    w_haloghost[i] = u_halo[cellghost] * u_g



'''
def ghost_value(w_c, w_ghost, cellid, name, normal, mesure):

    nbface = len(cellid)
    
    for i in range(nbface):
        if name[i] == 1 or name[i] == 2:
            #condition Neumann
            w_ghost[i].hu = w_c[cellid[i][0]].hu
            w_ghost[i].hv = w_c[cellid[i][0]].hv
            w_ghost[i].h  = w_c[cellid[i][0]].h
            w_ghost[i].Z  = w_c[cellid[i][0]].Z
            w_ghost[i].hc = w_c[cellid[i][0]].hc
        
        if name[i] == 3 or name[i] == 4:
        #slip conditions
            u_i = w_c[cellid[i][0]].hu/w_c[cellid[i][0]].h
            v_i = w_c[cellid[i][0]].hv/w_c[cellid[i][0]].h
        
            s_n = normal[i] / mesure[i]
        
            u_g = u_i*(s_n[1]*s_n[1] - s_n[0]*s_n[0]) - 2.0*v_i*s_n[0]*s_n[1]
            v_g = v_i*(s_n[0]*s_n[0] - s_n[1]*s_n[1]) - 2.0*u_i*s_n[0]*s_n[1]
        
            w_ghost[i].h = w_c[cellid[i][0]].h
            w_ghost[i].Z = w_c[cellid[i][0]].Z
            w_ghost[i].hc = w_c[cellid[i][0]].hc
        
            w_ghost[i].hu = w_c[cellid[i][0]].h * u_g
            w_ghost[i].hv = w_c[cellid[i][0]].h * v_g
'''
        

###############mach number############
@njit
def MN(rho_c:'float[:]',rhou_c:'float[:]',rhov_c:'float[:]',P_c:'float[:]', gamma:'float'):
    nb=len(rho_c)
    MN=np.zeros(nb)
    u_c=np.zeros(nb)
    v_c=np.zeros(nb)

    for i in range(nb):
        u_c[i]=rhou_c[i]/rho_c[i]
        v_c[i]=rhov_c[i]/rho_c[i]
        c=np.sqrt(gamma*P_c[i]/rho_c[i])
        MN[i]=np.sqrt(u_c[i]**2+v_c[i]**2)/c
    return MN



##################################"Double Mach Problem################################################"
@njit
def ghost_value_DoubleMach(rhog:'float[:]',Pg:'float[:]',rhoug:'float[:]',rhovg:'float[:]',
                     rhoEg:'float[:]', rhoc:'float[:]',Pc:'float[:]',rhouc:'float[:]',rhovc:'float[:]',rhoEc:'float[:]',
                     cellid:'int[:,:]', normal:'float[:,:]',mesure:'float[:]',center:'float[:,:]', t: 'float',faces_in:'float[:]',faces_out:'float[:]',faces_upper:'float[:]',faces_bottom:'float[:]'):
   
    s_n = np.zeros(2)
    for i in faces_in:
                                
        ### Neumann
        
        rhog[i]  = rhoc[cellid[i][0]]
        rhoug[i] = rhouc[cellid[i][0]]
        rhovg[i] = rhovc[cellid[i][0]]
        rhoEg[i] = rhoEc[cellid[i][0]]
        Pg[i]    = Pc[cellid[i][0]]
       # ug[i] = rhoug[i]/rhog[i]
        #vg[i] = rhovg[i]/rhog[i]
        
    for i in faces_out:
        
        ### Neumann
        
        rhog[i]  = rhoc[cellid[i][0]]
        rhoug[i] = rhouc[cellid[i][0]]
        rhovg[i] = rhovc[cellid[i][0]]
        rhoEg[i] = rhoEc[cellid[i][0]]
        Pg[i]    = Pc[cellid[i][0]]
        #ug[i] = rhoug[i]/rhog[i]
       # vg[i] = rhovg[i]/rhog[i]

           
   
    for i in faces_bottom :
        #### Double Mach
        
        xs = center[i][0]
        
        if xs > 1/6:
                            
            u_i = rhouc[cellid[i][0]]/rhoc[cellid[i][0]]
            v_i = rhovc[cellid[i][0]]/rhoc[cellid[i][0]]
    
            s_n[:] =  normal[i][0:2]
            s_n[0]=s_n[0]/mesure[i]
            s_n[1]=s_n[1]/mesure[i]
            u_g = u_i-2*(u_i*s_n[0]+v_i*s_n[1])*s_n[0]
            v_g = v_i-2*(u_i*s_n[0]+v_i*s_n[1])*s_n[1]
            
            #u_g = u_i*(s_n[1]*s_n[1] - s_n[0]*s_n[0]) - 2.0*v_i*s_n[0]*s_n[1]
            #v_g = v_i*(s_n[0]*s_n[0] - s_n[1]*s_n[1]) - 2.0*u_i*s_n[0]*s_n[1]
                        
            rhog[i]  = rhoc[cellid[i][0]]
            rhoug[i] = rhoc[cellid[i][0]] * u_g
            rhovg[i] = rhoc[cellid[i][0]] * v_g
            rhoEg[i] = rhoEc[cellid[i][0]]
            Pg[i] = Pc[cellid[i][0]]
            #ug[i] = rhoug[i]/rhog[i]
            #vg[i] = rhovg[i]/rhog[i]
            
        else:
            
            rhog[i]  = 8
            rhoug[i] = 8.25*8*np.cos(np.pi/6)
            rhovg[i] = -8.25*8*np.sin(np.pi/6)

            Pg[i]    = 116.5
        
            rhoEg[i]  = 0.5*(rhoug[i]**2 + rhovg[i]**2)/rhog[i] + Pg[i]/(1.4-1)            
            #ug[i]    = rhoug[i]/rhog[i]
            #vg[i]    = rhovg[i]/rhog[i]


    
    for i in faces_upper:
        
        ## Double Mach
        xcent = center[i][0]
        
        if xcent < 1/6 +(1+20*t)/np.sqrt(3):
            
            rhog[i]   = 8.0
            rhoug[i]  = 8.25*8*np.cos(np.pi/6)
            rhovg[i]  =-8.25*8*np.sin(np.pi/6)
            Pg[i]     = 116.5
            
        else:
            rhog[i]   = 1.4
            Pg[i]     = 1
            rhoug[i]  = 0.0
            rhovg[i]  = 0.0
            
        rhoEg[i]  = 0.5*(rhoug[i]**2 + rhovg[i]**2)/rhog[i] + Pg[i]/(1.4-1)            
       # ug[i]    = rhoug[i]/rhog[i]
      #  vg[i]    = rhovg[i]/rhog[i] 



@njit
def haloghost_value_DoubleMach(rho_halo:'float[:]',rhou_halo:'float[:]', rhov_halo:'float[:]', rhoE_halo:'float[:]', P_halo:'float[:]', 
                            rho_haloghost:'float[:]', rhou_haloghost:'float[:]',rhov_haloghost:'float[:]',rhoE_haloghost:'float[:]',P_haloghost:'float[:]'
                            ,haloghostcenter:'float[:,:,:]', halonodes:'float[:]', haloghostfaceinfo:'float[:,:,:]',center:'float[:,:]', t:'float'):
    
    
    s_n = np.zeros(2)
    for i in halonodes:
        for j in range(len(haloghostcenter[i])):
            if haloghostcenter[i][j][-1] != -1:
                if haloghostcenter[i][j][-2] == 1:
                    cellhalo  = np.int32(haloghostcenter[i][j][-3])
                    cellghost = np.int32(haloghostcenter[i][j][-1])
    
                    rho_haloghost[cellghost]   = rho_halo[cellhalo]
                    rhou_haloghost[cellghost]   = rhou_halo[cellhalo]
                    rhov_haloghost[cellghost]   = rhov_halo[cellhalo]
                    rhoE_haloghost[cellghost]   = rhoE_halo[cellhalo]
                    P_haloghost[cellghost]   = P_halo[cellhalo]

                elif haloghostcenter[i][j][-2] == 2:
                    cellhalo  = np.int32(haloghostcenter[i][j][-3])
                    cellghost = np.int32(haloghostcenter[i][j][-1])
    
                    rho_haloghost[cellghost]   = rho_halo[cellhalo]
                    rhou_haloghost[cellghost]   = rhou_halo[cellhalo]
                    rhov_haloghost[cellghost]   = rhov_halo[cellhalo]
                    rhoE_haloghost[cellghost]   = rhoE_halo[cellhalo]
                    P_haloghost[cellghost]   = P_halo[cellhalo]
                
                elif haloghostcenter[i][j][-2] == 3:
                    cellghost = int(haloghostcenter[i][j][-1])
                    cellhalo  = np.int32(haloghostcenter[i][j][-3])
                    xs = center[cellghost][0]
        
                    if xs > 1/6:
                        #print(rho_halo[cellghost])

                        u_i = rhou_halo[cellghost]/rho_halo[cellghost]
                        v_i = rhou_halo[cellghost]/rho_halo[cellghost]
                        
                        mesure = np.sqrt(haloghostfaceinfo[i][j][2]**2 + haloghostfaceinfo[i][j][3]**2) # + haloghostfaceinfo[i][5]**2)
        
                        s_n[0] = haloghostfaceinfo[i][j][2] / mesure
                        s_n[1] = haloghostfaceinfo[i][j][3] / mesure
                        
                        u_g = u_i*(s_n[1]*s_n[1] - s_n[0]*s_n[0]) - 2.0*v_i*s_n[0]*s_n[1]
                        v_g = v_i*(s_n[1]*s_n[1] - s_n[0]*s_n[0]) - 2.0*v_i*s_n[0]*s_n[1]

                        rhou_haloghost[cellghost] = rho_haloghost[cellghost]* u_g
                        rhov_haloghost[cellghost] = rho_haloghost[cellghost]* v_g

                        rho_haloghost[cellghost]   = rho_halo[cellhalo]
                        P_haloghost[cellghost]   = P_halo[cellhalo]

                    else:
                             
                        rho_haloghost[cellghost]   = 8.0
                        rhou_haloghost[cellghost]  = 8.25*8*np.cos(np.pi/6)
                        rhov_haloghost[cellghost]  =-8.25*8*np.sin(np.pi/6)
                        P_haloghost[cellghost]     = 116.5
                    rhoE_haloghost[cellghost]  = 0.5*(rhou_haloghost[cellghost]**2 + rhov_haloghost[cellghost]**2)/rho_haloghost[cellghost] + P_haloghost[cellghost]/(1.4-1)              
               
                elif haloghostcenter[i][j][-2] == 4:
                    cellghost = np.int32(haloghostcenter[i][j][-1])
                    cellhalo  = np.int32(haloghostcenter[i][j][-3])
                            ## Double Mach
                    xcent = center[cellghost][0]
                    
                    if xcent < 1/6 +(1+20*t)/np.sqrt(3):
                        
                        rho_haloghost[cellghost]   = 8.0
                        rhou_haloghost[cellghost]  = 8.25*8*np.cos(np.pi/6)
                        rhov_haloghost[cellghost]  =-8.25*8*np.sin(np.pi/6)
                        P_haloghost[cellghost]     = 116.5
                        rhoE_haloghost[cellghost]  = 0.5*(rhou_haloghost[cellghost]**2 + rhov_haloghost[cellghost]**2)/rho_haloghost[cellghost] + P_haloghost[cellghost]/(1.4-1)  
                        
                    else:
                        rho_haloghost[cellghost]   = 1.4
                        P_haloghost[cellghost]     = 1
                        rhou_haloghost[cellghost]  = 0.0
                        rhov_haloghost[cellghost]  = 0.0
                        rhoE_haloghost[cellghost]  = 0.5*(rhou_haloghost[cellghost]**2 + rhov_haloghost[cellghost]**2)/rho_haloghost[cellghost] + P_haloghost[cellghost]/(1.4-1)            
                    # ug[i]    = rhoug[i]/rhog[i]
                    #  vg[i]    = rhovg[i]/rhog[i] 

################################GAMM CHANNAL####################################

@njit
def ghost_value_gamm(rhog:'float[:]',Pg:'float[:]',rhoug:'float[:]',rhovg:'float[:]',rhoEg:'float[:]', rhoc:'float[:]',Pc:'float[:]',rhouc:'float[:]',rhovc:'float[:]',rhoEc:'float[:]', cellid:'int[:,:]', normal:'float[:,:]',mesure:'float[:]',faces_in:'float[:]',faces_out:'float[:]',faces_upper:'float[:]',faces_bottom:'float[:]'):
    nbface = len(cellid)
    s_n=np.zeros(2)
   
    for i in range(nbface):
    
        if i in faces_in:
            kappa=1.4
            p0=101391.8555
            rho0=1.1845
            p=min(p0,Pc[cellid[i][0]])
            M2=(pow(p / p0, -(kappa - 1.0) / kappa) - 1.0) * 2.0 / (kappa - 1.0)
            tmp = 1.0 + (kappa - 1.0) * 0.5 * M2
            rho = rho0 * pow(tmp, -1.0 /(kappa - 1.0))
            a2 = kappa * p / rho
            rhoVel = rho*np.sqrt(M2 * a2)
            
            rhoe = p / (kappa - 1.) + 0.5 * (pow(rhoVel, 2))
            
            rhog[i] = rho
            Pg[i] = p
            rhoEg[i] = rhoe
            rhoug[i] = rhoVel
            rhovg[i] = 0.
            
        
        elif i in faces_out:
                kappa=1.4
                MaIs=0.675
                p0=101391.8555
                p = p0*pow(1. + (kappa - 1.) / 2. * MaIs*MaIs, kappa / (1. - kappa))
                

                
                he = p / (kappa - 1.) + 0.5 * (pow(rhouc[cellid[i][0]],2) + pow(rhovc[cellid[i][0]],2))
                rhog[i] = rhoc[cellid[i][0]]            
                rhoug[i] = rhouc[cellid[i][0]]
                rhovg[i] = rhovc[cellid[i][0]]
                rhoEg[i] = he
                Pg[i] = p
                
            
        elif  (i in faces_upper or i in faces_bottom) :

            u_i = rhouc[cellid[i][0]]/rhoc[cellid[i][0]]
            v_i = rhovc[cellid[i][0]]/rhoc[cellid[i][0]]

            
            s_n[:] =  normal[i][0:2]
            s_n[0]=s_n[0]/mesure[i]
            s_n[1]=s_n[1]/mesure[i]
            #u_g = u_i-2*(u_i*s_n[0]+v_i*s_n[1])*s_n[0]
            #v_g = v_i-2*(u_i*s_n[0]+v_i*s_n[1])*s_n[1]
            
            u_g = u_i*(s_n[1]*s_n[1] - s_n[0]*s_n[0]) - 2.0*v_i*s_n[0]*s_n[1]
            v_g = v_i*(s_n[0]*s_n[0] - s_n[1]*s_n[1]) - 2.0*u_i*s_n[0]*s_n[1]
            
            rhog[i] = rhoc[cellid[i][0]]
            rhoug[i] = rhoc[cellid[i][0]] * u_g
            rhovg[i] = rhoc[cellid[i][0]] * v_g
            rhoEg[i] = rhoEc[cellid[i][0]]
            Pg[i] = Pc[cellid[i][0]]
        else:
            rhog[i] = 0.
            Pg[i] = 0.
            rhoEg[i] = 0.
            rhoug[i] = 0.
            rhovg[i] = 0.
    
    
    ################################test1###########################################

@njit
def ghost_value_test(rhog:'float[:]',Pg:'float[:]',rhoug:'float[:]',rhovg:'float[:]',
                     rhoEg:'float[:]', rhoc:'float[:]',Pc:'float[:]',rhouc:'float[:]',rhovc:'float[:]',rhoEc:'float[:]',
                     cellid:'int32[:,:]', normal:'float[:,:]',mesure:'float[:]',faces_in:'float[:]'
                      ,faces_out:'float[:]',faces_upper:'float[:]',faces_bottom:'float[:]', rl:'float', rr:'float', pl:'float', pr:'float'):
   
    s_n = np.zeros(2)
    for i in faces_in:
                                
        ### Neumann
        
        rhog[i]  = rl
        rhoug[i] = rhouc[cellid[i][0]]
        rhovg[i] = rhovc[cellid[i][0]]
        Pg[i]    = pl
        rhoEg[i]=Pg[i]/(1.4-1) +0.5*(rhoug[i]**2+rhovg[i]**2)/(rhog[i])
       
    for i in faces_out:
        
        ### Neumann
        rhog[i]  = rr
        rhoug[i] = rhouc[cellid[i][0]]
        rhovg[i] = rhovc[cellid[i][0]]
        Pg[i]    = pr
        rhoEg[i]=Pg[i]/(1.4-1) +0.5*(rhoug[i]**2+rhovg[i]**2)/(rhog[i])
      
    for i in faces_upper :
               
        u_i = rhouc[cellid[i][0]]/rhoc[cellid[i][0]]
        v_i = rhovc[cellid[i][0]]/rhoc[cellid[i][0]]

        s_n[:] =  normal[i][0:2]
        s_n[0]=s_n[0]/mesure[i]
        s_n[1]=s_n[1]/mesure[i]
    
        u_g = u_i*(s_n[1]*s_n[1] - s_n[0]*s_n[0]) - 2.0*v_i*s_n[0]*s_n[1]
        v_g = v_i*(s_n[0]*s_n[0] - s_n[1]*s_n[1]) - 2.0*u_i*s_n[0]*s_n[1]
        #u_g = u_i-2*(u_i*s_n[0]+v_i*s_n[1])*s_n[0]
        #v_g = v_i-2*(u_i*s_n[0]+v_i*s_n[1])*s_n[1]
                
        rhog[i]  = rhoc[cellid[i][0]]
        rhoug[i] = rhoc[cellid[i][0]] * u_g
        rhovg[i] = rhoc[cellid[i][0]] * v_g
        Pg[i] = Pc[cellid[i][0]]
        rhoEg[i]=Pg[i]/(1.4-1) +0.5*(rhoug[i]**2+rhovg[i]**2)/(rhog[i])
        
    for i in faces_bottom:
        
        u_i = rhouc[cellid[i][0]]/rhoc[cellid[i][0]]
        v_i = rhovc[cellid[i][0]]/rhoc[cellid[i][0]]

        s_n[:] =  normal[i][0:2]
        s_n[0]=s_n[0]/mesure[i]
        s_n[1]=s_n[1]/mesure[i]
        
        u_g = u_i*(s_n[1]*s_n[1] - s_n[0]*s_n[0]) - 2.0*v_i*s_n[0]*s_n[1]
        v_g = v_i*(s_n[0]*s_n[0] - s_n[1]*s_n[1]) - 2.0*u_i*s_n[0]*s_n[1]
        #u_g = u_i-2*(u_i*s_n[0]+v_i*s_n[1])*s_n[0]
        #v_g = v_i-2*(u_i*s_n[0]+v_i*s_n[1])*s_n[1]
        
        rhog[i]  = rhoc[cellid[i][0]]
        rhoug[i] = rhoc[cellid[i][0]] * u_g
        rhovg[i] = rhoc[cellid[i][0]] * v_g
        Pg[i] = Pc[cellid[i][0]]
        rhoEg[i]=Pg[i]/(1.4-1) +0.5*(rhoug[i]**2+rhovg[i]**2)/(rhog[i])

#@njit
def haloghost_value_test(rho_halo:'float[:]',rhou_halo:'float[:]', rhov_halo:'float[:]', rhoE_halo:'float[:]', P_halo:'float[:]', 
                            rho_haloghost:'float[:]', rhou_haloghost:'float[:]',rhov_haloghost:'float[:]',rhoE_haloghost:'float[:]',P_haloghost:'float[:]'
                            ,haloghostcenter:'float[:,:,:]', halonodes:'float[:]', haloghostfaceinfo:'float[:,:,:]',center:'float[:,:]', t:'float',
                            rl:'float', rr:'float', pl:'float', pr:'float'):
    s_n = np.zeros(2)
    for i in halonodes:
        for j in range(len(haloghostcenter[i])):
            if haloghostcenter[i][j][-1] != -1:
                if haloghostcenter[i][j][-2] == 1:
                    print("here")
                    cellhalo  = np.int32(haloghostcenter[i][j][-3])
                    cellghost = np.int32(haloghostcenter[i][j][-1])

                    rho_haloghost[cellghost]    = rl
                    rhou_haloghost[cellghost]   = rhou_halo[cellhalo]
                    rhov_haloghost[cellghost]   = rhov_halo[cellhalo]
                    P_haloghost[cellghost]      = pl
                    rhoE_haloghost[cellghost]   = pl/(1.4-1) +0.5*(rhou_haloghost[cellghost]**2+rhov_haloghost[cellghost] **2)/(rho_haloghost[cellghost])


                elif haloghostcenter[i][j][-2] == 2:
                    print("here 2", haloghostcenter[i][j])
                    cellhalo  = np.int32(haloghostcenter[i][j][-3])
                    cellghost = np.int32(haloghostcenter[i][j][-1])
    
                    rho_haloghost[cellghost]    = rr
                    rhou_haloghost[cellghost]   = rhou_halo[cellhalo]
                    rhov_haloghost[cellghost]   = rhov_halo[cellhalo]
                    P_haloghost[cellghost]      = pr
                    rhoE_haloghost[cellghost]   = pr/(1.4-1) +0.5*(rhou_haloghost[cellghost]**2+rhov_haloghost[cellghost] **2)/(rho_haloghost[cellghost])

                elif haloghostcenter[i][j][-2] == 3:
                    print("here 3")
                    cellghost = int(haloghostcenter[i][j][-1])

                    u_i = rhou_halo[cellghost]/rho_halo[cellghost]
                    v_i = rhou_halo[cellghost]/rho_halo[cellghost]
                    
                    mesure = np.sqrt(haloghostfaceinfo[i][j][2]**2 + haloghostfaceinfo[i][j][3]**2) # + haloghostfaceinfo[i][5]**2)
    
                    s_n[0] = haloghostfaceinfo[i][j][2] / mesure
                    s_n[1] = haloghostfaceinfo[i][j][3] / mesure
                    
                    u_g = u_i*(s_n[1]*s_n[1] - s_n[0]*s_n[0]) - 2.0*v_i*s_n[0]*s_n[1]
                    v_g = v_i*(s_n[1]*s_n[1] - s_n[0]*s_n[0]) - 2.0*v_i*s_n[0]*s_n[1]

                    rhou_haloghost[cellghost] = rho_haloghost[cellghost]* u_g
                    rhov_haloghost[cellghost] = rho_haloghost[cellghost]* v_g

                    rho_haloghost[cellghost]   = rho_halo[cellhalo]
                    P_haloghost[cellghost]   = P_halo[cellhalo]
                    rhoE_haloghost[cellghost]   = P_haloghost[cellghost]/(1.4-1) +0.5*(rhou_haloghost[cellghost]**2+rhov_haloghost[cellghost] **2)/(rho_haloghost[cellghost])
                    
                elif haloghostcenter[i][j][-2] == 4:
                    print("here 4")
                    cellghost = int(haloghostcenter[i][j][-1])

                    u_i = rhou_halo[cellghost]/rho_halo[cellghost]
                    v_i = rhou_halo[cellghost]/rho_halo[cellghost]
                   
                    
                    mesure = np.sqrt(haloghostfaceinfo[i][j][2]**2 + haloghostfaceinfo[i][j][3]**2) # + haloghostfaceinfo[i][5]**2)
                    print(mesure)
                    
                    s_n[0] = haloghostfaceinfo[i][j][2] / mesure
                    s_n[1] = haloghostfaceinfo[i][j][3] / mesure
                    
                    u_g = u_i*(s_n[1]*s_n[1] - s_n[0]*s_n[0]) - 2.0*v_i*s_n[0]*s_n[1]
                    v_g = v_i*(s_n[1]*s_n[1] - s_n[0]*s_n[0]) - 2.0*v_i*s_n[0]*s_n[1]

                    rhou_haloghost[cellghost] = rho_haloghost[cellghost]* u_g
                    rhov_haloghost[cellghost] = rho_haloghost[cellghost]* v_g

                    rho_haloghost[cellghost]   = rho_halo[cellhalo]
                    P_haloghost[cellghost]   = P_halo[cellhalo]
                    rhoE_haloghost[cellghost]   = P_haloghost[cellghost]/(1.4-1) +0.5*(rhou_haloghost[cellghost]**2+rhov_haloghost[cellghost] **2)/(rho_haloghost[cellghost])
@njit
def ghost_value_RS(rhog:'float[:]',Pg:'float[:]',rhoug:'float[:]',rhovg:'float[:]',
                     rhoEg:'float[:]', rhoc:'float[:]',Pc:'float[:]',rhouc:'float[:]',rhovc:'float[:]',rhoEc:'float[:]',
                     cellid:'int[:,:]',faces_in:'float[:]'
                      ,faces_out:'float[:]',faces_upper:'float[:]',faces_bottom:'float[:]'):
   
    s_n = np.zeros(2)
    for i in faces_in:
                                
        ### Neumann
        rhog[i]  = rhoc[cellid[i][0]]
        rhoug[i] = rhouc[cellid[i][0]]
        rhovg[i] = rhovc[cellid[i][0]]
        Pg[i]    = Pc[cellid[i][0]]
        rhoEg[i]=rhoEc[cellid[i][0]]
       
    for i in faces_out:
        
        ### Neumann
        rhog[i]  = rhoc[cellid[i][0]]
        rhoug[i] = rhouc[cellid[i][0]]
        rhovg[i] = rhovc[cellid[i][0]]
        Pg[i]    = Pc[cellid[i][0]]
        rhoEg[i]=rhoEc[cellid[i][0]]
       
      
    for i in faces_upper :
        rhog[i]  = rhoc[cellid[i][0]]
        rhoug[i] = rhouc[cellid[i][0]]
        rhovg[i] = rhovc[cellid[i][0]]
        Pg[i]    = Pc[cellid[i][0]]
        rhoEg[i]=rhoEc[cellid[i][0]]
       

    for i in faces_bottom:
        
        rhog[i]  = rhoc[cellid[i][0]]
        rhoug[i] = rhouc[cellid[i][0]]
        rhovg[i] = rhovc[cellid[i][0]]
        Pg[i]    = Pc[cellid[i][0]]
        rhoEg[i]=rhoEc[cellid[i][0]]
       
@njit
def haloghost_value_RS(rho_halo:'float[:]',rhou_halo:'float[:]', rhov_halo:'float[:]', rhoE_halo:'float[:]', P_halo:'float[:]', 
                            rho_haloghost:'float[:]', rhou_haloghost:'float[:]',rhov_haloghost:'float[:]',rhoE_haloghost:'float[:]',P_haloghost:'float[:]'
                            ,haloghostcenter:'float[:,:,:]', halonodes:'float[:]', haloghostfaceinfo:'float[:,:,:]',center:'float[:,:]', t:'float'):
   
    for i in halonodes:
        for j in range(len(haloghostcenter[i])):
            if haloghostcenter[i][j][-1] != -1:
                #print('haloghostcenter',haloghostcenter[i][j][-2])
                #if haloghostcenter[i][j][-2] == 1:
                cellhalo  = np.int32(haloghostcenter[i][j][-3])
                cellghost = np.int32(haloghostcenter[i][j][-1])

                rho_haloghost[cellghost]   = rho_halo[cellhalo]
                rhou_haloghost[cellghost]   = rhou_halo[cellhalo]
                rhov_haloghost[cellghost]   = rhov_halo[cellhalo]
                rhoE_haloghost[cellghost]   = rhoE_halo[cellhalo]
                P_haloghost[cellghost]   = P_halo[cellhalo]
                '''
                elif haloghostcenter[i][j][-2] == 2:
                    cellhalo  = np.int32(haloghostcenter[i][j][-3])
                    cellghost = np.int32(haloghostcenter[i][j][-1])
    
                    rho_haloghost[cellghost]   = rho_halo[cellhalo]
                    rhou_haloghost[cellghost]   = rhou_halo[cellhalo]
                    rhov_haloghost[cellghost]   = rhov_halo[cellhalo]
                    rhoE_haloghost[cellghost]   = rhoE_halo[cellhalo]
                    P_haloghost[cellghost]   = P_halo[cellhalo]
                elif haloghostcenter[i][j][-2] == 3:
                    cellhalo  = np.int32(haloghostcenter[i][j][-3])
                    cellghost = np.int32(haloghostcenter[i][j][-1])
    
                    rho_haloghost[cellghost]   = rho_halo[cellhalo]
                    rhou_haloghost[cellghost]   = rhou_halo[cellhalo]
                    rhov_haloghost[cellghost]   = rhov_halo[cellhalo]
                    rhoE_haloghost[cellghost]   = rhoE_halo[cellhalo]
                    P_haloghost[cellghost]   = P_halo[cellhalo]

                elif haloghostcenter[i][j][-2] == 4:
                    cellhalo  = np.int32(haloghostcenter[i][j][-3])
                    cellghost = np.int32(haloghostcenter[i][j][-1])
    
                    rho_haloghost[cellghost]   = rho_halo[cellhalo]
                    rhou_haloghost[cellghost]   = rhou_halo[cellhalo]
                    rhov_haloghost[cellghost]   = rhov_halo[cellhalo]
                    rhoE_haloghost[cellghost]   = rhoE_halo[cellhalo]
                    P_haloghost[cellghost]   = P_halo[cellhalo]
                '''